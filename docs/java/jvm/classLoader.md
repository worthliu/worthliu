# ClassLoader双亲加载模型

## JDK加载过程

>每个Java程序执行前都必须经过**编译、加载、连接、和初始化**这几个阶段，后三个阶段如下图：

![loading](/images/loading.png)

>1. **加载**:***将编译后的java类文件（也就是`.class`文件）中的二进制数据读入内存，并将其放在运行时数据区的方法区内，然后在堆区创建一个`Java.lang.Class`对象，用来封装类在方法区的数据结构***。即加载后最终得到的是`Class`对象，并且更加值得注意的是：该`Java.lang.Class`对象是单实例的，无论这个类创建了多少个对象，他的`Class`对象时唯一的。而加载并获取该`Class`对象可以通过三种途径：
  1. `Class.forName`（类的全路径）；
  2. `实例对象.class`(属性)；
  3. `实例对象.getClass()`；
2. 在**连接和初始化**阶段，其实静态变量经过了两次赋值：
  1. 第一次是静态变量类型的默认值；
  2. 第二次是我们真正赋给静态变量的值；

## Java类使用方式

Java对类的使用分为两种方式：主动使用和被动使用。其中主动使用如下图：

![classusing](/images/classusing.png)

>区别：
  1. `Class cl=A.class;`JVM将使用类A的类装载器,将类A装入内存(前提是:类A还没有装入内存),不对类A做类的初始化工作.返回类A的Class的对象
  2. `Class cl=对象引用o.getClass();`返回引用o运行时真正所指的对象(因为:儿子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象 
  3. `Class.forName("类名");`JAVA人都知道.装入类A,并做类的初始化


>从JVM的角度看，我们使用关键字`new`创建一个类的时候，这个类可以没有被加载。
* 但是使用`Class`对象的`newInstance()`方法的时候，就必须保证：
1. 这个类已经加载；
2. 这个类已经连接了。而完成上面两个步骤的正是Class的静态方法`forName()`所完成的,这个静态方法调用了启动类加载器,即加载java API的那个加载器。 
  * `newInstance`: 弱类型。低效率。只能调用无参构造。 
  * `new`: 强类型。相对高效。能调用任何public构造。